# test if the MSRI can effectively predict the traffic state
# using `lima.rou.xml` to generate the traffic state of MSRI
# calibrate the result using the road data from SUMO simulation

# ps: `lima.rou.xml` is generated by `duarouter.exe`, which can
# find the static shortest paths.


from TTFM import TTFM, edgeInfo
from constants import jNodes, getEdgeLength, sEdgesInfo

import xml.etree.ElementTree as ET
from collections import defaultdict


def getRouInfo():
    routeFile = '../SUMOFiles/lima.rou.xml'
    elementTree = ET.ElementTree(file=routeFile)
    root = elementTree.getroot()
    routesInfo = []
    for veh in root:
        departTime = float(veh.attrib['depart'])
        for rou in veh:
            edges = rou.attrib['edges']
            routesInfo.append([departTime, edges])
    
    return routesInfo


def updateMSRI(msri: TTFM, lk: str, currT: float, flag: int):
    currInterval = int(currT / msri.interval)
    if flag:
        msri.ifTable[lk][currInterval] += 1
    else:
        msri.ofTable[lk][currInterval] += 1


def updateMSRInodeTab(msri: TTFM, nd: str, currT: float, segs: int):
    currInterval = int(currT / msri.interval)
    for i in range(segs):
        msri.jnodeTable[nd][currInterval + i] += 1

# aftering applying node model, the node table should update each step
# interval = 5 seconds
def TTFMRes(testMSRI, routesInfo):
    for row in routesInfo:
        dt = row[0]
        rou = row[1].split(' ')
        for lk in rou:
            lkEI = edgeInfo(lk, testMSRI)
            inwait = 0
            while not lkEI.canFlowIn(dt + inwait):
                inwait += 1
            # if vehicle flow out upstream link, and can't flow into the downstream link
            # it will stay in the end node of the upstream link i.e. the 
            # start node of the downstream link
            nodeID = lk.split('to')[0]
            if nodeID in jNodes:
                nodeTableSegs = inwait // testMSRI.interval + 1
                updateMSRInodeTab(testMSRI, nodeID, dt, nodeTableSegs)
            dt += inwait
            updateMSRI(testMSRI, lk, dt, 1)
            FFTT = lkEI.length / lkEI.freeSpeed
            dt += FFTT
            outWait = 0
            while not lkEI.canFlowOut(dt + outWait):
                outWait += 1
            dt += outWait
            updateMSRI(testMSRI, lk, dt, 0)

# interval = 60 seconds
def SUMOres():
    edgesFlowInSUMO = defaultdict(list)
    edgesFlowOutSUMO = defaultdict(list)
    elementTree = ET.parse('../SUMOFiles/duarouter.edgesinfo.xml')
    root = elementTree.getroot()
    for interval in root:
        for edge in interval:
            eID = edge.attrib['id']
            entered = int(edge.attrib['entered'])
            left = int(edge.attrib['left'])
            edgesFlowInSUMO[eID].append(entered)
            edgesFlowOutSUMO[eID].append(left)

    return edgesFlowInSUMO, edgesFlowOutSUMO


def segCum(inList, cumStep):
    outList = []
    segs = 0
    cnt = 0
    for elem in inList:
        segs += elem
        cnt += 1
        if cnt % cumStep == 0:
            outList.append(segs)
            segs = 0
    return outList


if __name__ == '__main__':
    import numpy as np
    import json
    import random

    # TTFM simulation results: cumulative vehicles of flow-in and flow-out
    def write2File(data, fileName):
        with open('SimResults/'+fileName+'.json', 'w') as f:
            f.write(data)


    routesInfo = getRouInfo()
    testTTFM = TTFM('lima', 10000, 5)
    TTFMRes(testTTFM, routesInfo)

    efiSUMO, efoSUMO = SUMOres()

    allEdgesList = list(efiSUMO.keys())
    # some edges are full of zero, choose thses edges for presentation
    sampleEdgesList = ['195to100245', '102500to102506', '104371to104353', '103588to103587']

    edgeFlowinTTFM = {}
    edgeFlowoutTTFM = {}
    edgeFlowinSUMO = {}
    edgeFlowoutSUMO = {}
    for eid in sampleEdgesList:
        edgeFlowinTTFM[eid] = testTTFM.ifTable[eid]
        edgeFlowoutTTFM[eid] = testTTFM.ofTable[eid]
        edgeFlowinSUMO[eid] = efiSUMO[eid]
        edgeFlowoutSUMO[eid] = efoSUMO[eid]


    write2File(json.dumps(edgeFlowinTTFM), 'efiTTFM')
    write2File(json.dumps(edgeFlowoutTTFM), 'efoTTFM')
    write2File(json.dumps(edgeFlowinSUMO), 'efiSUMO')
    write2File(json.dumps(edgeFlowoutSUMO), 'efoSUMO')

    # MAE comparison

    # flowinMAE = {}
    # flowoutMAE = {}

    # for ik, iv in efiSUMO.items():
    #     flowinTTFM = testMSRI.ifTable[ik]
    #     cutFITTFM = np.array(segCum(flowinTTFM, 60)[:30], dtype=float)
    #     cutFISUMO = np.array(segCum(iv, 5)[:30], dtype=float)
    #     inError = np.abs(cutFITTFM - cutFISUMO)
    #     flowinMAE[ik] = np.sum(inError) / len(cutFISUMO)


    # for ok, ov in efoSUMO.items():
    #     flowoutTTFM = testMSRI.ofTable[ok]
    #     cutFOTTFM = np.array(segCum(flowoutTTFM, 60)[:30], dtype=float)
    #     cutFOSUMO = np.array(segCum(ov, 5)[:30], dtype=float)
    #     outError = np.abs(cutFOTTFM - cutFOSUMO)
    #     flowoutMAE[ok] = np.sum(outError) / len(cutFOSUMO)


    # jsonFlowinMAE = json.dumps(flowinMAE)
    # jsonFlowoutMAE = json.dumps(flowoutMAE)

    # with open('SimResults/flowinMAPE.json', 'w') as fi:
    #     fi.write(jsonFlowinMAE)


    # with open('SimResults/flowoutMAPE.json', 'w') as fo:
    #     fo.write(jsonFlowoutMAE)