# test if the MSRI can effectively predict the traffic state
# using `lima.rou.xml` to generate the traffic state of MSRI
# calibrate the result using the road data from SUMO simulation

# ps: `lima.rou.xml` is generated by `duarouter.exe`, which can
# find the static shortest paths.


from TTFM import TTFM, edgeInfo
from constants import jNodes, getEdgeLength, sEdgesInfo

import xml.etree.ElementTree as ET
from collections import defaultdict


def getRouInfo():
    routeFile = '../SUMOFiles/lima.rou.xml'
    elementTree = ET.ElementTree(file=routeFile)
    root = elementTree.getroot()
    routesInfo = []
    for veh in root:
        departTime = float(veh.attrib['depart'])
        for rou in veh:
            edges = rou.attrib['edges']
            routesInfo.append([departTime, edges])
    
    return routesInfo


def updateMSRI(msri: TTFM, lk: str, currT: float, flag: int):
    currInterval = int(currT / msri.interval)
    if flag:
        msri.ifTable[lk][currInterval] += 1
    else:
        msri.ofTable[lk][currInterval] += 1


def updateMSRInodeTab(msri: TTFM, nd: str, currT: float, segs: int):
    currInterval = int(currT / msri.interval)
    for i in range(segs):
        msri.jnodeTable[nd][currInterval + i] += 1

# aftering applying node model, the node table should update each step
# interval = 5 seconds
def MSRIres(testMSRI, routesInfo):
    for row in routesInfo:
        dt = row[0]
        rou = row[1].split(' ')
        for lk in rou:
            lkEI = edgeInfo(lk, testMSRI)
            inwait = 0
            while not lkEI.canFlowIn(dt + inwait):
                inwait += 1
            # if vehicle flow out upstream link, and can't flow into the downstream link
            # it will stay in the end node of the upstream link i.e. the 
            # start node of the downstream link
            nodeID = lk.split('to')[0]
            if nodeID in jNodes:
                nodeTableSegs = inwait // testMSRI.interval + 1
                updateMSRInodeTab(testMSRI, nodeID, dt, nodeTableSegs)
            dt += inwait
            updateMSRI(testMSRI, lk, dt, 1)
            FFTT = lkEI.length / lkEI.freeSpeed
            dt += FFTT
            outWait = 0
            while not lkEI.canFlowOut(dt + outWait):
                outWait += 1
            dt += outWait
            updateMSRI(testMSRI, lk, dt, 0)

# interval = 60 seconds
def SUMOres():
    edgesFlowInSUMO = defaultdict(list)
    edgesFlowOutSUMO = defaultdict(list)
    elementTree = ET.parse('../SUMOFiles/duarouter.edgesinfo.xml')
    root = elementTree.getroot()
    for interval in root:
        for edge in interval:
            eID = edge.attrib['id']
            entered = int(edge.attrib['entered'])
            left = int(edge.attrib['left'])
            edgesFlowInSUMO[eID].append(entered)
            edgesFlowOutSUMO[eID].append(left)

    return edgesFlowInSUMO, edgesFlowOutSUMO


def segCum(inList, cumStep):
    outList = []
    segs = 0
    cnt = 0
    for elem in inList:
        segs += elem
        cnt += 1
        if cnt % cumStep == 0:
            outList.append(segs)
            segs = 0
    return outList


def getMSRITT(msri, edgesList):
    edgesTTMSRI = defaultdict(list)
    for ed in edgesList:
        ei = edgeInfo(ed, msri)
        for i in range(8000):
            try:
                eTT = ei.getOutTime(i) - i
                edgesTTMSRI[ed].append(eTT)
            except:
                pass

    return edgesTTMSRI


def getSUMOTT(edgesList):
    edgesTTSUMO = defaultdict(list)
    elementTree = ET.parse('../SUMOFiles/duarouter.edgesinfo.xml')
    root = elementTree.getroot()
    for interval in root:
        for edge in interval:
            eID = edge.attrib['id']
            if eID in edgesList:
                try:
                    eTT = float(edge.attrib['traveltime'])
                except:
                    eTT = getEdgeLength(eID) / sEdgesInfo[eID][2]
                edgesTTSUMO[eID].append(eTT)
    return edgesTTSUMO


if __name__ == '__main__':
    import numpy as np
    import json

    routesInfo = getRouInfo()
    testMSRI = TTFM('lima', 10000, 5)
    MSRIres(testMSRI, routesInfo)

    efiSUMO, efoSUMO = SUMOres()

    flowinMAPE = {}
    flowoutMAPE = {}

    for ik, iv in efiSUMO.items():
        flowinTTFM = testMSRI.ifTable[ik]
        cutFITTFM = np.array(segCum(flowinTTFM, 60)[:30], dtype=float)
        cutFISUMO = np.array(segCum(iv, 5)[:30], dtype=float)
        inError = np.abs(cutFITTFM - cutFISUMO)
        flowinMAPE[ik] = np.sum(
            np.divide(inError, cutFISUMO, out=np.zeros_like(inError), where=cutFISUMO!=0)
            ) / len(cutFISUMO)


    for ok, ov in efoSUMO.items():
        flowoutTTFM = testMSRI.ofTable[ok]
        cutFOTTFM = np.array(segCum(flowoutTTFM, 60)[:30], dtype=float)
        cutFOSUMO = np.array(segCum(ov, 5)[:30], dtype=float)
        outError = np.abs(cutFOTTFM - cutFOSUMO)
        flowoutMAPE[ik] = np.sum(
            np.divide(outError, cutFOSUMO, out=np.zeros_like(outError), where=cutFOSUMO!=0)
            ) / len(cutFOSUMO)


    jsonFlowinMAPE = json.dumps(flowinMAPE)
    jsonFlowoutMAPE = json.dumps(flowoutMAPE)

    with open('testResults/flowinMAPE.json', 'w') as fi:
        fi.write(jsonFlowinMAPE)


    with open('testResults/flowoutMAPE.json', 'w') as fo:
        fo.write(jsonFlowoutMAPE)