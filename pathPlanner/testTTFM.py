# test if the MSRI can effectively predict the traffic state
# using `lima.rou.xml` to generate the traffic state of MSRI
# calibrate the result using the road data from SUMO simulation

# ps: `lima.rou.xml` is generated by `duarouter.exe`, which can
# find the static shortest paths.


from TTFM import TTFM, edgeInfo
from constants import jNodes, getEdgeLength, sEdgesInfo

import xml.etree.ElementTree as ET
from collections import defaultdict


def getRouInfo():
    routeFile = '../SUMOFiles/lima.rou.xml'
    elementTree = ET.ElementTree(file=routeFile)
    root = elementTree.getroot()
    routesInfo = []
    for veh in root:
        departTime = float(veh.attrib['depart'])
        for rou in veh:
            edges = rou.attrib['edges']
            routesInfo.append([departTime, edges])
    
    return routesInfo


def updateMSRI(msri: TTFM, lk: str, currT: float, flag: int):
    currInterval = int(currT / msri.interval)
    if flag:
        msri.ifTable[lk][currInterval] += 1
    else:
        msri.ofTable[lk][currInterval] += 1


def updateMSRInodeTab(msri: TTFM, nd: str, currT: float, segs: int):
    currInterval = int(currT / msri.interval)
    for i in range(segs):
        msri.jnodeTable[nd][currInterval + i] += 1

# aftering applying node model, the node table should update each step
# interval = 5 seconds
def MSRIres(testMSRI, routesInfo, edgesList):
    for row in routesInfo:
        dt = row[0]
        rou = row[1].split(' ')
        for lk in rou:
            lkEI = edgeInfo(lk, testMSRI)
            inwait = 0
            while not lkEI.canFlowIn(dt + inwait):
                inwait += 1
            # if vehicle flow out upstream link, and can't flow into the downstream link
            # it will stay in the end node of the upstream link i.e. the 
            # start node of the downstream link
            nodeID = lk.split('to')[0]
            if nodeID in jNodes:
                nodeTableSegs = inwait // testMSRI.interval + 1
                updateMSRInodeTab(testMSRI, nodeID, dt, nodeTableSegs)
            dt += inwait
            updateMSRI(testMSRI, lk, dt, 1)
            FFTT = lkEI.length / lkEI.freeSpeed
            dt += FFTT
            outWait = 0
            while not lkEI.canFlowOut(dt + outWait):
                outWait += 1
            dt += outWait
            updateMSRI(testMSRI, lk, dt, 0)

    edgesFlowInMSRI = {}
    edgesFlowOutMSRI = {}
    for ed in edgesList:
        edgesFlowInMSRI[ed] = testMSRI.ifTable[ed]
        edgesFlowOutMSRI[ed] = testMSRI.ofTable[ed]

    return edgesFlowInMSRI, edgesFlowOutMSRI

# interval = 60 seconds
def SUMOres(edgesList):
    edgesFlowInSUMO = defaultdict(list)
    edgesFlowOutSUMO = defaultdict(list)
    elementTree = ET.parse('../SUMOFiles/duarouter.edgesinfo.xml')
    root = elementTree.getroot()
    for interval in root:
        for edge in interval:
            eID = edge.attrib['id']
            entered = int(edge.attrib['entered'])
            left = int(edge.attrib['left'])
            if eID in edgesList:
                edgesFlowInSUMO[eID].append(entered)
                edgesFlowOutSUMO[eID].append(left)

    return edgesFlowInSUMO, edgesFlowOutSUMO


def getMSRITT(msri, edgesList):
    edgesTTMSRI = defaultdict(list)
    for ed in edgesList:
        ei = edgeInfo(ed, msri)
        for i in range(8000):
            try:
                eTT = ei.getOutTime(i) - i
                edgesTTMSRI[ed].append(eTT)
            except:
                pass

    return edgesTTMSRI


def getSUMOTT(edgesList):
    edgesTTSUMO = defaultdict(list)
    elementTree = ET.parse('../SUMOFiles/duarouter.edgesinfo.xml')
    root = elementTree.getroot()
    for interval in root:
        for edge in interval:
            eID = edge.attrib['id']
            if eID in edgesList:
                try:
                    eTT = float(edge.attrib['traveltime'])
                except:
                    eTT = getEdgeLength(eID) / sEdgesInfo[eID][2]
                edgesTTSUMO[eID].append(eTT)
    return edgesTTSUMO


if __name__ == '__main__':
    randEdgesList = [
        '100653to100655', '103588to103587', '101933to101935', '102500to102506'
        ]
    routesInfo = getRouInfo()
    testMSRI = TTFM('lima', 10000, 5)
    efiMSRI, efoMSRI = MSRIres(testMSRI, routesInfo, randEdgesList)

    TTedgesList = [
        '100653to100655', '103588to103587', '101933to101935', '102500to102506'
        ]

    edgesTTMSRI = getMSRITT(testMSRI, TTedgesList)
    edgesTTSUMO = getSUMOTT(TTedgesList)

    efiSUMO, efoSUMO = SUMOres(randEdgesList)

    import json

    jefiMSRI = json.dumps(efiMSRI)
    jefoMSRI = json.dumps(efoMSRI)
    jefiSUMO = json.dumps(efiSUMO)
    jefoSUMO = json.dumps(efoSUMO)

    def writeFile(data, fileName):
        with open(fileName, 'w') as f:
            f.write(data)

    writeFile(jefiMSRI, 'testResults/efiMSRI.json')
    writeFile(jefoMSRI, 'testResults/efoMSRI.json')
    writeFile(jefiSUMO, 'testResults/efiSUMO.json')
    writeFile(jefoSUMO, 'testResults/efoSUMO.json')
