# prediction-based path planning experiments

from curses import flash
from TTFM import TTFM, edgeInfo, TDshortestPath
from constants import jNodes, getEdgeLength, sEdgesInfo

import xml.etree.ElementTree as ET
from progressbar import *


def getRouInfo():
    routeFile = '../SUMOFiles/lima.rou.xml'
    elementTree = ET.ElementTree(file=routeFile)
    root = elementTree.getroot()
    routesInfo = []
    for veh in root:
        departTime = float(veh.attrib['depart'])
        for rou in veh:
            edges = rou.attrib['edges']
            routesInfo.append([departTime, edges])
    
    return routesInfo


def updateTTFM(msri: TTFM, lk: str, currT: float, flag: int):
    currInterval = int(currT / msri.interval)
    if flag:
        msri.ifTable[lk][currInterval] += 1
    else:
        msri.ofTable[lk][currInterval] += 1


def updateTTFMnodeTab(msri: TTFM, nd: str, currT: float, segs: int):
    currInterval = int(currT / msri.interval)
    for i in range(segs):
            msri.jnodeTable[nd][currInterval + i] += 1

# aftering applying node model, the node table should update each step
# interval = 5 seconds
def TTFMRes(testMSRI, routesInfo):
    for row in routesInfo:
        dt = row[0]
        rou = row[1].split(' ')
        for lk in rou:
            lkEI = edgeInfo(lk, testMSRI)
            inwait = 0
            while not lkEI.canFlowIn(dt + inwait):
                inwait += 1
            # if vehicle flow out upstream link, and can't flow into the downstream link
            # it will stay in the end node of the upstream link i.e. the 
            # start node of the downstream link
            nodeID = lk.split('to')[0]
            if nodeID in jNodes:
                nodeTableSegs = inwait // testMSRI.interval + 1
                updateTTFMnodeTab(testMSRI, nodeID, dt, nodeTableSegs)
            dt += inwait
            updateTTFM(testMSRI, lk, dt, 1)
            FFTT = lkEI.length / lkEI.freeSpeed
            dt += FFTT
            outWait = 0
            while not lkEI.canFlowOut(dt + outWait):
                outWait += 1
            dt += outWait
            updateTTFM(testMSRI, lk, dt, 0)


def PPPRunner(tm: TTFM, routesInfo: list):
    plannedRoutes = []
    cnt = 0
    for row in routesInfo:
        dt = row[0]
        rou = row[1].split(' ')
        oriID = rou[0].split('to')[0]
        desID = rou[-1].split('to')[-1]
        try:
            path, sroute = TDshortestPath.searchPath(oriID, desID, dt, tm)
        except Exception as e:
            # print(e)
            pass
        routeEdges = ' '.join(sroute)
        plannedRoutes.append([dt, routeEdges])
        cnt += 1
        sys.stdout.write('\r' + 'Processing: ' + str(round(cnt/len(routesInfo), 4)))
        sys.stdout.flush()
    return plannedRoutes


def writeRou(vid: str, departTime: float, edges: str) -> str:
    output = '''    <vehicle id="{}" depart="{}">
        <route edges="{}"/>
    </vehicle>'''.format(vid, departTime, edges)
    return output


if __name__ == '__main__':
    import sys
    # 纯 HV 环境下的历史交通流
    routesInfo = getRouInfo()
    print('Route infomation extracted sucessfully.')
    historicalTTFM = TTFM('lima', 10000, 5)
    TTFMRes(historicalTTFM, routesInfo)
    print('Historical TTFM generated successfully.')


    PPRoutes = PPPRunner(historicalTTFM, routesInfo)
    print('Prediction-based routes has been generated.')
    # the topology generated by `buildTopologyM.py` is a little different from 
    # that of SUMO. The below roads can't find a valid connections, so we should
    # remove them. But this will not make big impacts to the final results.
    # we finally generate 31855 vehicles in `TTFMGPP.rou.xml` which have the 
    # same start point, end point and departure time as those in `lima.rou.xml`. 
    # The number of vehicles in `lima.rou.xml` is 31861, so these roads cause few impacts.
    ErrorPath = set([2662, 5142, 9250, 10285, 11092, 11384])
    with open('../SUMOFiles/PPPlanner.rou.xml', 'w') as wf:
        print('''<routes>''', file=wf)
        for i in range(len(PPRoutes)):
            if i not in ErrorPath:
                vid = str(i)
                departTime = float(PPRoutes[i][0])
                rEdges = PPRoutes[i][1]
                vRou = writeRou(vid, departTime, rEdges)
                print(vRou, file=wf)
        print('''</routes>''', file=wf)